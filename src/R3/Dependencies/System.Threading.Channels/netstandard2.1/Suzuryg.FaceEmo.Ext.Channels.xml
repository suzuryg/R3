<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Suzuryg.FaceEmo.Ext.Channels</name>
    </assembly>
    <members>
        <member name="T:System.VoidResult">
            <summary>An empty struct, used to represent void in generic types.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation.s_availableSentinel">
            <summary>Sentinel object used in a field to indicate the operation is available for use.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation.s_completedSentinel">
            <summary>Sentinel object used in a field to indicate the operation has completed</summary>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation.ThrowIncompleteOperationException">
            <summary>Throws an exception indicating that the operation's result was accessed before the operation completed.</summary>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation.ThrowMultipleContinuations">
            <summary>Throws an exception indicating that multiple continuations can't be set for the same operation.</summary>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation.ThrowIncorrectCurrentIdException">
            <summary>Throws an exception indicating that the operation was used after it was supposed to be used.</summary>
        </member>
        <member name="T:System.Threading.Channels.AsyncOperation`1">
            <summary>The representation of an asynchronous operation that has a result value.</summary>
            <typeparam name="TResult">Specifies the type of the result.  May be <see cref="T:System.VoidResult"/>.</typeparam>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._registration">
            <summary>Registration with a provided cancellation token.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._pooled">
            <summary>true if this object is pooled and reused; otherwise, false.</summary>
            <remarks>
            If the operation is cancelable, then it can't be pooled.  And if it's poolable, there must never be race conditions to complete it,
            which is the main reason poolable objects can't be cancelable, as then cancellation could fire, the object could get reused,
            and then we may end up trying to complete an object that's used by someone else.
            </remarks>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._runContinuationsAsynchronously">
            <summary>Whether continuations should be forced to run asynchronously.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._completionReserved">
            <summary>Only relevant to cancelable operations; 0 if the operation hasn't had completion reserved, 1 if it has.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._result">
            <summary>The result of the operation.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._error">
            <summary>Any error that occurred during the operation.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._continuation">
            <summary>The continuation callback.</summary>
            <remarks>
            This may be the completion sentinel if the operation has already completed.
            This may be the available sentinel if the operation is being pooled and is available for use.
            This may be null if the operation is pending.
            This may be another callback if the operation has had a callback hooked up with OnCompleted.
            </remarks>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._continuationState">
            <summary>State object to be passed to <see cref="F:System.Threading.Channels.AsyncOperation`1._continuation"/>.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._schedulingContext">
            <summary>Scheduling context (a <see cref="T:System.Threading.SynchronizationContext"/> or <see cref="T:System.Threading.Tasks.TaskScheduler"/>) to which to queue the continuation. May be null.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._executionContext">
            <summary>Execution context to use when invoking <see cref="F:System.Threading.Channels.AsyncOperation`1._continuation"/>. May be null.</summary>
        </member>
        <member name="F:System.Threading.Channels.AsyncOperation`1._currentId">
            <summary>The token value associated with the current operation.</summary>
            <remarks>
            IValueTaskSource operations on this instance are only valid if the provided token matches this value,
            which is incremented once GetResult is called to avoid multiple awaits on the same instance.
            </remarks>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.#ctor(System.Boolean,System.Threading.CancellationToken,System.Boolean)">
            <summary>Initializes the interactor.</summary>
            <param name="runContinuationsAsynchronously">true if continuations should be forced to run asynchronously; otherwise, false.</param>
            <param name="cancellationToken">The cancellation token used to cancel the operation.</param>
            <param name="pooled">Whether this instance is pooled and reused.</param>
        </member>
        <member name="P:System.Threading.Channels.AsyncOperation`1.Next">
            <summary>Gets or sets the next operation in the linked list of operations.</summary>
        </member>
        <member name="P:System.Threading.Channels.AsyncOperation`1.CancellationToken">
            <summary>Gets the cancellation token associated with this operation.</summary>
        </member>
        <member name="P:System.Threading.Channels.AsyncOperation`1.ValueTask">
            <summary>Gets a <see cref="P:System.Threading.Channels.AsyncOperation`1.ValueTask"/> backed by this instance and its current token.</summary>
        </member>
        <member name="P:System.Threading.Channels.AsyncOperation`1.ValueTaskOfT">
            <summary>Gets a <see cref="T:System.Threading.Tasks.ValueTask`1"/> backed by this instance and its current token.</summary>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.GetStatus(System.Int16)">
            <summary>Gets the current status of the operation.</summary>
            <param name="token">The token that must match <see cref="F:System.Threading.Channels.AsyncOperation`1._currentId"/>.</param>
        </member>
        <member name="P:System.Threading.Channels.AsyncOperation`1.IsCompleted">
            <summary>Gets whether the operation has completed.</summary>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.GetResult(System.Int16)">
            <summary>Gets the result of the operation.</summary>
            <param name="token">The token that must match <see cref="F:System.Threading.Channels.AsyncOperation`1._currentId"/>.</param>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.System#Threading#Tasks#Sources#IValueTaskSource#GetResult(System.Int16)">
            <summary>Gets the result of the operation.</summary>
            <param name="token">The token that must match <see cref="F:System.Threading.Channels.AsyncOperation`1._currentId"/>.</param>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.TryOwnAndReset">
            <summary>Attempts to take ownership of the pooled instance.</summary>
            <returns>true if the instance is now owned by the caller, in which case its state has been reset; otherwise, false.</returns>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.OnCompleted(System.Action{System.Object},System.Object,System.Int16,System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags)">
            <summary>Hooks up a continuation callback for when the operation has completed.</summary>
            <param name="continuation">The callback.</param>
            <param name="state">The state to pass to the callback.</param>
            <param name="token">The current token that must match <see cref="F:System.Threading.Channels.AsyncOperation`1._currentId"/>.</param>
            <param name="flags">Flags that influence the behavior of the callback.</param>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.UnregisterCancellation">
            <summary>Unregisters from cancellation and returns whether cancellation already started.</summary>
            <returns>
            true if either the instance wasn't cancelable or cancellation successfully unregistered without cancellation having started.
            false if cancellation successfully unregistered after cancellation was initiated.
            </returns>
            <remarks>
            This is important for two reasons:
            1. To avoid leaking a registration into a token, so it must be done prior to completing the operation.
            2. To avoid having to worry about concurrent completion; once invoked, the caller can be guaranteed
            that no one else will try to complete the operation (assuming the caller is properly constructed
            and themselves guarantees only a single completer other than through cancellation).
            </remarks>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.TrySetResult(`0)">
            <summary>Completes the operation with a success state and the specified result.</summary>
            <param name="item">The result value.</param>
            <returns>true if the operation could be successfully transitioned to a completed state; false if it was already completed.</returns>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.TrySetException(System.Exception)">
            <summary>Completes the operation with a failed state and the specified error.</summary>
            <param name="exception">The error.</param>
            <returns>true if the operation could be successfully transitioned to a completed state; false if it was already completed.</returns>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.TrySetCanceled(System.Threading.CancellationToken)">
            <summary>Completes the operation with a failed state and a cancellation error.</summary>
            <param name="cancellationToken">The cancellation token that caused the cancellation.</param>
            <returns>true if the operation could be successfully transitioned to a completed state; false if it was already completed.</returns>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.TryReserveCompletionIfCancelable">
            <summary>Attempts to reserve this instance for completion.</summary>
            <remarks>
            This will always return true for non-cancelable objects, as they only ever have a single owner
            responsible for completion.  For cancelable operations, this will attempt to atomically transition
            from Initialized to CompletionReserved.
            </remarks>
        </member>
        <member name="M:System.Threading.Channels.AsyncOperation`1.SignalCompletion">
            <summary>Signals to a registered continuation that the operation has now completed.</summary>
        </member>
        <member name="T:System.Threading.Channels.VoidAsyncOperationWithData`1">
            <summary>The representation of an asynchronous operation that has a result value and carries additional data with it.</summary>
            <typeparam name="TData">Specifies the type of data being written.</typeparam>
        </member>
        <member name="M:System.Threading.Channels.VoidAsyncOperationWithData`1.#ctor(System.Boolean,System.Threading.CancellationToken,System.Boolean)">
            <summary>Initializes the interactor.</summary>
            <param name="runContinuationsAsynchronously">true if continuations should be forced to run asynchronously; otherwise, false.</param>
            <param name="cancellationToken">The cancellation token used to cancel the operation.</param>
            <param name="pooled">Whether this instance is pooled and reused.</param>
        </member>
        <member name="P:System.Threading.Channels.VoidAsyncOperationWithData`1.Item">
            <summary>The item being written.</summary>
        </member>
        <member name="T:System.Threading.Channels.BoundedChannel`1">
            <summary>Provides a channel with a bounded capacity.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._mode">
            <summary>The mode used when the channel hits its bound.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._itemDropped">
            <summary>The delegate that will be invoked when the channel hits its bound and an item is dropped from the channel.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._completion">
            <summary>Task signaled when the channel has completed.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._bufferedCapacity">
            <summary>The maximum capacity of the channel.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._items">
            <summary>Items currently stored in the channel waiting to be read.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._blockedReaders">
            <summary>Readers waiting to read from the channel.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._blockedWriters">
            <summary>Writers waiting to write to the channel.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._waitingReadersTail">
            <summary>Linked list of WaitToReadAsync waiters.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._waitingWritersTail">
            <summary>Linked list of WaitToWriteAsync waiters.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._runContinuationsAsynchronously">
            <summary>Whether to force continuations to be executed asynchronously from producer writes.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannel`1._doneWriting">
            <summary>Set to non-null once Complete has been called.</summary>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannel`1.SyncObj">
            <summary>Gets an object used to synchronize all state on the instance.</summary>
        </member>
        <member name="M:System.Threading.Channels.BoundedChannel`1.#ctor(System.Int32,System.Threading.Channels.BoundedChannelFullMode,System.Boolean,System.Action{`0})">
            <summary>Initializes the <see cref="T:System.Threading.Channels.BoundedChannel`1"/>.</summary>
            <param name="bufferedCapacity">The positive bounded capacity for the channel.</param>
            <param name="mode">The mode used when writing to a full channel.</param>
            <param name="runContinuationsAsynchronously">Whether to force continuations to be executed asynchronously.</param>
            <param name="itemDropped">Delegate that will be invoked when an item is dropped from the channel. See <see cref="T:System.Threading.Channels.BoundedChannelFullMode"/>.</param>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannel`1.BoundedChannelReader.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel. This should only be used by the debugger.</summary>
            <remarks>
            Unlike <see cref="P:System.Threading.Channels.BoundedChannel`1.BoundedChannelReader.Count"/>, avoids locking so as to not block the debugger if another suspended thread is holding the lock.
            Hence, this must only be used from the debugger in a serialized context.
            </remarks>
        </member>
        <member name="M:System.Threading.Channels.BoundedChannel`1.BoundedChannelReader.DequeueItemAndPostProcess">
            <summary>Dequeues an item, and then fixes up our state around writers and completion.</summary>
            <returns>The dequeued item.</returns>
        </member>
        <member name="M:System.Threading.Channels.BoundedChannel`1.BoundedChannelReader.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannel`1.BoundedChannelWriter.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel. This should only be used by the debugger.</summary>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannel`1.BoundedChannelWriter.CapacityForDebugger">
            <summary>Gets the capacity of the channel. This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.BoundedChannel`1.BoundedChannelWriter.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannel`1.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel.  This should only be used by the debugger.</summary>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannel`1.ChannelIsClosedForDebugger">
            <summary>Report if the channel is closed or not. This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.BoundedChannel`1.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="T:System.Threading.Channels.BoundedChannelFullMode">
            <summary>Specifies the behavior to use when writing to a bounded channel that is already full.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannelFullMode.Wait">
            <summary>Wait for space to be available in order to complete the write operation.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannelFullMode.DropNewest">
            <summary>Remove and ignore the newest item in the channel in order to make room for the item being written.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannelFullMode.DropOldest">
            <summary>Remove and ignore the oldest item in the channel in order to make room for the item being written.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannelFullMode.DropWrite">
            <summary>Drop the item being written.</summary>
        </member>
        <member name="T:System.Threading.Channels.Channel">
            <summary>Provides static methods for creating channels.</summary>
        </member>
        <member name="M:System.Threading.Channels.Channel.CreateUnbounded``1">
            <summary>Creates an unbounded channel usable by any number of readers and writers concurrently.</summary>
            <returns>The created channel.</returns>
        </member>
        <member name="M:System.Threading.Channels.Channel.CreateUnbounded``1(System.Threading.Channels.UnboundedChannelOptions)">
            <summary>Creates an unbounded channel subject to the provided options.</summary>
            <typeparam name="T">Specifies the type of data in the channel.</typeparam>
            <param name="options">Options that guide the behavior of the channel.</param>
            <returns>The created channel.</returns>
        </member>
        <member name="M:System.Threading.Channels.Channel.CreateBounded``1(System.Int32)">
            <summary>Creates a channel with the specified maximum capacity.</summary>
            <typeparam name="T">Specifies the type of data in the channel.</typeparam>
            <param name="capacity">The maximum number of items the channel may store.</param>
            <returns>The created channel.</returns>
            <remarks>
            Channels created with this method apply the <see cref="F:System.Threading.Channels.BoundedChannelFullMode.Wait"/>
            behavior and prohibit continuations from running synchronously.
            </remarks>
        </member>
        <member name="M:System.Threading.Channels.Channel.CreateBounded``1(System.Threading.Channels.BoundedChannelOptions)">
            <summary>Creates a channel subject to the provided options.</summary>
            <typeparam name="T">Specifies the type of data in the channel.</typeparam>
            <param name="options">Options that guide the behavior of the channel.</param>
            <returns>The created channel.</returns>
        </member>
        <member name="M:System.Threading.Channels.Channel.CreateBounded``1(System.Threading.Channels.BoundedChannelOptions,System.Action{``0})">
            <summary>Creates a channel subject to the provided options.</summary>
            <typeparam name="T">Specifies the type of data in the channel.</typeparam>
            <param name="options">Options that guide the behavior of the channel.</param>
            <param name="itemDropped">Delegate that will be called when item is being dropped from channel. See <see cref="T:System.Threading.Channels.BoundedChannelFullMode"/>.</param>
            <returns>The created channel.</returns>
        </member>
        <member name="T:System.Threading.Channels.ChannelClosedException">
            <summary>Exception thrown when a channel is used after it's been closed.</summary>
            <summary>Exception thrown when a channel is used after it's been closed.</summary>
        </member>
        <member name="M:System.Threading.Channels.ChannelClosedException.#ctor">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException"/> class.</summary>
        </member>
        <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException"/> class.</summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException"/> class.</summary>
            <param name="innerException">The exception that is the cause of this exception.</param>
        </member>
        <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.String,System.Exception)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException"/> class.</summary>
            <param name="message">The message that describes the error.</param>
            <param name="innerException">The exception that is the cause of this exception.</param>
        </member>
        <member name="M:System.Threading.Channels.ChannelClosedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Initializes a new instance of the <see cref="T:System.Threading.Channels.ChannelClosedException"/> class with serialized data.</summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="T:System.Threading.Channels.ChannelOptions">
            <summary>Provides options that control the behavior of channel instances.</summary>
        </member>
        <member name="P:System.Threading.Channels.ChannelOptions.SingleWriter">
            <summary>
            <code>true</code> if writers to the channel guarantee that there will only ever be at most one write operation
            at a time; <code>false</code> if no such constraint is guaranteed.
            </summary>
            <remarks>
            If true, the channel may be able to optimize certain operations based on knowing about the single-writer guarantee.
            The default is false.
            </remarks>
        </member>
        <member name="P:System.Threading.Channels.ChannelOptions.SingleReader">
            <summary>
            <code>true</code> if readers from the channel guarantee that there will only ever be at most one read operation
            at a time; <code>false</code> if no such constraint is guaranteed.
            </summary>
            <remarks>
            If true, the channel may be able to optimize certain operations based on knowing about the single-reader guarantee.
            The default is false.
            </remarks>
        </member>
        <member name="P:System.Threading.Channels.ChannelOptions.AllowSynchronousContinuations">
            <summary>
            <code>true</code> if operations performed on a channel may synchronously invoke continuations subscribed to
            notifications of pending async operations; <code>false</code> if all continuations should be invoked asynchronously.
            </summary>
            <remarks>
            Setting this option to <code>true</code> can provide measurable throughput improvements by avoiding
            scheduling additional work items. However, it may come at the cost of reduced parallelism, as for example a producer
            may then be the one to execute work associated with a consumer, and if not done thoughtfully, this can lead
            to unexpected interactions. The default is false.
            </remarks>
        </member>
        <member name="T:System.Threading.Channels.BoundedChannelOptions">
            <summary>Provides options that control the behavior of <see cref="T:System.Threading.Channels.BoundedChannel`1"/> instances.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannelOptions._capacity">
            <summary>The maximum number of items the bounded channel may store.</summary>
        </member>
        <member name="F:System.Threading.Channels.BoundedChannelOptions._mode">
            <summary>The behavior incurred by write operations when the channel is full.</summary>
        </member>
        <member name="M:System.Threading.Channels.BoundedChannelOptions.#ctor(System.Int32)">
            <summary>Initializes the options.</summary>
            <param name="capacity">The maximum number of items the bounded channel may store.</param>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannelOptions.Capacity">
            <summary>Gets or sets the maximum number of items the bounded channel may store.</summary>
        </member>
        <member name="P:System.Threading.Channels.BoundedChannelOptions.FullMode">
            <summary>Gets or sets the behavior incurred by write operations when the channel is full.</summary>
        </member>
        <member name="T:System.Threading.Channels.UnboundedChannelOptions">
            <summary>Provides options that control the behavior of <see cref="T:System.Threading.Channels.UnboundedChannel`1"/> instances.</summary>
        </member>
        <member name="T:System.Threading.Channels.ChannelReader`1">
            <summary>
            Provides a base class for reading from a channel.
            </summary>
            <typeparam name="T">Specifies the type of data that may be read from the channel.</typeparam>
        </member>
        <member name="P:System.Threading.Channels.ChannelReader`1.Completion">
            <summary>
            Gets a <see cref="T:System.Threading.Tasks.Task"/> that completes when no more data will ever
            be available to be read from this channel.
            </summary>
        </member>
        <member name="P:System.Threading.Channels.ChannelReader`1.CanCount">
            <summary>Gets whether <see cref="P:System.Threading.Channels.ChannelReader`1.Count"/> is available for use on this <see cref="T:System.Threading.Channels.ChannelReader`1"/> instance.</summary>
        </member>
        <member name="P:System.Threading.Channels.ChannelReader`1.CanPeek">
            <summary>Gets whether <see cref="M:System.Threading.Channels.ChannelReader`1.TryPeek(`0@)"/> is available for use on this <see cref="T:System.Threading.Channels.ChannelReader`1"/> instance.</summary>
        </member>
        <member name="P:System.Threading.Channels.ChannelReader`1.Count">
            <summary>Gets the current number of items available from this channel reader.</summary>
            <exception cref="T:System.NotSupportedException">Counting is not supported on this instance.</exception>
        </member>
        <member name="M:System.Threading.Channels.ChannelReader`1.TryRead(`0@)">
            <summary>Attempts to read an item from the channel.</summary>
            <param name="item">The read item, or a default value if no item could be read.</param>
            <returns>true if an item was read; otherwise, false if no item was read.</returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelReader`1.TryPeek(`0@)">
            <summary>Attempts to peek at an item from the channel.</summary>
            <param name="item">The peeked item, or a default value if no item could be peeked.</param>
            <returns>true if an item was read; otherwise, false if no item was read.</returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelReader`1.WaitToReadAsync(System.Threading.CancellationToken)">
            <summary>Returns a <see cref="T:System.Threading.Tasks.ValueTask`1"/> that will complete when data is available to read.</summary>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/> used to cancel the wait operation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that will complete with a <c>true</c> result when data is available to read
            or with a <c>false</c> result when no further data will ever be available to be read.
            </returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelReader`1.ReadAsync(System.Threading.CancellationToken)">
            <summary>Asynchronously reads an item from the channel.</summary>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/> used to cancel the read operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that represents the asynchronous read operation.</returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelReader`1.ReadAllAsync(System.Threading.CancellationToken)">
            <summary>Creates an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1"/> that enables reading all of the data from the channel.</summary>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> to use to cancel the enumeration.</param>
            <remarks>
            Each <see cref="M:System.Collections.Generic.IAsyncEnumerator`1.MoveNextAsync"/> call that returns <c>true</c> will read the next item out of the channel.
            <see cref="M:System.Collections.Generic.IAsyncEnumerator`1.MoveNextAsync"/> will return false once no more data is or will ever be available to read.
            </remarks>
            <returns>The created async enumerable.</returns>
        </member>
        <member name="T:System.Threading.Channels.ChannelUtilities">
            <summary>Provides internal helper methods for implementing channels.</summary>
        </member>
        <member name="F:System.Threading.Channels.ChannelUtilities.s_doneWritingSentinel">
            <summary>Sentinel object used to indicate being done writing.</summary>
        </member>
        <member name="F:System.Threading.Channels.ChannelUtilities.s_trueTask">
            <summary>A cached task with a Boolean true result.</summary>
        </member>
        <member name="F:System.Threading.Channels.ChannelUtilities.s_falseTask">
            <summary>A cached task with a Boolean false result.</summary>
        </member>
        <member name="F:System.Threading.Channels.ChannelUtilities.s_neverCompletingTask">
            <summary>A cached task that never completes.</summary>
        </member>
        <member name="M:System.Threading.Channels.ChannelUtilities.Complete(System.Threading.Channels.TaskCompletionSource,System.Exception)">
            <summary>Completes the specified TaskCompletionSource.</summary>
            <param name="tcs">The source to complete.</param>
            <param name="error">
            The optional exception with which to complete.
            If this is null or the DoneWritingSentinel, the source will be completed successfully.
            If this is an OperationCanceledException, it'll be completed with the exception's token.
            Otherwise, it'll be completed as faulted with the exception.
            </param>
        </member>
        <member name="M:System.Threading.Channels.ChannelUtilities.GetInvalidCompletionValueTask``1(System.Exception)">
            <summary>Gets a value task representing an error.</summary>
            <typeparam name="T">Specifies the type of the value that would have been returned.</typeparam>
            <param name="error">The error.  This may be <see cref="F:System.Threading.Channels.ChannelUtilities.s_doneWritingSentinel"/>.</param>
            <returns>The failed task.</returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelUtilities.FailOperations``2(System.Collections.Generic.Deque{``0},System.Exception)">
            <summary>Removes all operations from the queue, failing each.</summary>
            <param name="operations">The queue of operations to complete.</param>
            <param name="error">The error with which to complete each operations.</param>
        </member>
        <member name="M:System.Threading.Channels.ChannelUtilities.CreateInvalidCompletionException(System.Exception)">
            <summary>Creates and returns an exception object to indicate that a channel has been closed.</summary>
        </member>
        <member name="T:System.Threading.Channels.ChannelWriter`1">
            <summary>
            Provides a base class for writing to a channel.
            </summary>
            <typeparam name="T">Specifies the type of data that may be written to the channel.</typeparam>
        </member>
        <member name="M:System.Threading.Channels.ChannelWriter`1.TryComplete(System.Exception)">
            <summary>Attempts to mark the channel as being completed, meaning no more data will be written to it.</summary>
            <param name="error">An <see cref="T:System.Exception"/> indicating the failure causing no more data to be written, or null for success.</param>
            <returns>
            true if this operation successfully completes the channel; otherwise, false if the channel could not be marked for completion,
            for example due to having already been marked as such, or due to not supporting completion.
            </returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelWriter`1.TryWrite(`0)">
            <summary>Attempts to write the specified item to the channel.</summary>
            <param name="item">The item to write.</param>
            <returns>true if the item was written; otherwise, false if it wasn't written.</returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelWriter`1.WaitToWriteAsync(System.Threading.CancellationToken)">
            <summary>Returns a <see cref="T:System.Threading.Tasks.ValueTask`1"/> that will complete when space is available to write an item.</summary>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/> used to cancel the wait operation.</param>
            <returns>
            A <see cref="T:System.Threading.Tasks.ValueTask`1"/> that will complete with a <c>true</c> result when space is available to write an item
            or with a <c>false</c> result when no further writing will be permitted.
            </returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelWriter`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>Asynchronously writes an item to the channel.</summary>
            <param name="item">The value to write to the channel.</param>
            <param name="cancellationToken">A <see cref="T:System.Threading.CancellationToken"/> used to cancel the write operation.</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that represents the asynchronous write operation.</returns>
        </member>
        <member name="M:System.Threading.Channels.ChannelWriter`1.Complete(System.Exception)">
            <summary>Mark the channel as being complete, meaning no more items will be written to it.</summary>
            <param name="error">Optional Exception indicating a failure that's causing the channel to complete.</param>
            <exception cref="T:System.InvalidOperationException">The channel has already been marked as complete.</exception>
        </member>
        <member name="T:System.Threading.Channels.Channel`1">
            <summary>Provides a base class for channels that support reading and writing elements of type <typeparamref name="T"/>.</summary>
            <typeparam name="T">Specifies the type of data readable and writable in the channel.</typeparam>
        </member>
        <member name="T:System.Threading.Channels.Channel`2">
            <summary>
            Provides a base class for channels that support reading elements of type <typeparamref name="TRead"/>
            and writing elements of type <typeparamref name="TWrite"/>.
            </summary>
            <typeparam name="TWrite">Specifies the type of data that may be written to the channel.</typeparam>
            <typeparam name="TRead">Specifies the type of data that may be read from the channel.</typeparam>
        </member>
        <member name="P:System.Threading.Channels.Channel`2.Reader">
            <summary>Gets the readable half of this channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.Channel`2.Writer">
            <summary>Gets the writable half of this channel.</summary>
        </member>
        <member name="M:System.Threading.Channels.Channel`2.op_Implicit(System.Threading.Channels.Channel{`0,`1})~System.Threading.Channels.ChannelReader{`1}">
            <summary>Implicit cast from a channel to its readable half.</summary>
            <param name="channel">The channel being cast.</param>
        </member>
        <member name="M:System.Threading.Channels.Channel`2.op_Implicit(System.Threading.Channels.Channel{`0,`1})~System.Threading.Channels.ChannelWriter{`0}">
            <summary>Implicit cast from a channel to its writable half.</summary>
            <param name="channel">The channel being cast.</param>
        </member>
        <member name="T:System.Threading.Channels.SingleConsumerUnboundedChannel`1">
            <summary>
            Provides a buffered channel of unbounded capacity for use by any number
            of writers but at most a single reader at a time.
            </summary>
        </member>
        <member name="F:System.Threading.Channels.SingleConsumerUnboundedChannel`1._completion">
            <summary>Task that indicates the channel has completed.</summary>
        </member>
        <member name="F:System.Threading.Channels.SingleConsumerUnboundedChannel`1._items">
            <summary>
            A concurrent queue to hold the items for this channel.  The queue itself supports at most
            one writer and one reader at a time; as a result, since this channel supports multiple writers,
            all write access to the queue must be synchronized by the channel.
            </summary>
        </member>
        <member name="F:System.Threading.Channels.SingleConsumerUnboundedChannel`1._runContinuationsAsynchronously">
            <summary>Whether to force continuations to be executed asynchronously from producer writes.</summary>
        </member>
        <member name="F:System.Threading.Channels.SingleConsumerUnboundedChannel`1._doneWriting">
            <summary>non-null if the channel has been marked as complete for writing.</summary>
        </member>
        <member name="F:System.Threading.Channels.SingleConsumerUnboundedChannel`1._blockedReader">
            <summary>An <see cref="T:System.Threading.Channels.AsyncOperation`1"/> if there's a blocked reader.</summary>
        </member>
        <member name="F:System.Threading.Channels.SingleConsumerUnboundedChannel`1._waitingReader">
            <summary>A waiting reader (e.g. WaitForReadAsync) if there is one.</summary>
        </member>
        <member name="M:System.Threading.Channels.SingleConsumerUnboundedChannel`1.#ctor(System.Boolean)">
            <summary>Initialize the channel.</summary>
            <param name="runContinuationsAsynchronously">Whether to force continuations to be executed asynchronously.</param>
        </member>
        <member name="P:System.Threading.Channels.SingleConsumerUnboundedChannel`1.UnboundedChannelReader.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel.  This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.SingleConsumerUnboundedChannel`1.UnboundedChannelReader.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.SingleConsumerUnboundedChannel`1.UnboundedChannelWriter.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel. This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.SingleConsumerUnboundedChannel`1.UnboundedChannelWriter.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.SingleConsumerUnboundedChannel`1.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel.  This should only be used by the debugger.</summary>
        </member>
        <member name="P:System.Threading.Channels.SingleConsumerUnboundedChannel`1.ChannelIsClosedForDebugger">
            <summary>Report if the channel is closed or not. This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.SingleConsumerUnboundedChannel`1.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="T:System.Threading.Channels.TaskCompletionSource">
            <summary>Shims the non-generic TaskCompletionSource for targets that don't provide it.</summary>
        </member>
        <member name="M:System.Threading.Channels.TaskCompletionSource.#ctor(System.Threading.Tasks.TaskCreationOptions)">
            <summary>Creates a <see cref="T:System.Threading.Channels.TaskCompletionSource"/> with the specified options.</summary>
            <remarks>
            The <see cref="T:System.Threading.Tasks.Task"/> created by this instance and accessible through its <see cref="T:System.Threading.Tasks.Task"/> property
            will be instantiated using the specified <paramref name="creationOptions"/>.
            </remarks>
            <param name="creationOptions">The options to use when creating the underlying <see cref="T:System.Threading.Tasks.Task"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The <paramref name="creationOptions"/> represent options invalid for use
            with a <see cref="T:System.Threading.Channels.TaskCompletionSource"/>.
            </exception>
        </member>
        <member name="M:System.Threading.Channels.TaskCompletionSource.TrySetResult">
            <summary>
            Attempts to transition the underlying <see cref="T:System.Threading.Tasks.Task"/> into the <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> state.
            </summary>
            <returns>True if the operation was successful; otherwise, false.</returns>
            <remarks>
            This operation will return false if the <see cref="T:System.Threading.Tasks.Task"/> is already in one of the three final states:
            <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/>,
            <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/>, or
            <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/>.
            </remarks>
        </member>
        <member name="T:System.Threading.Channels.UnboundedChannel`1">
            <summary>Provides a buffered channel of unbounded capacity.</summary>
        </member>
        <member name="F:System.Threading.Channels.UnboundedChannel`1._completion">
            <summary>Task that indicates the channel has completed.</summary>
        </member>
        <member name="F:System.Threading.Channels.UnboundedChannel`1._items">
            <summary>The items in the channel.</summary>
        </member>
        <member name="F:System.Threading.Channels.UnboundedChannel`1._blockedReaders">
            <summary>Readers blocked reading from the channel.</summary>
        </member>
        <member name="F:System.Threading.Channels.UnboundedChannel`1._runContinuationsAsynchronously">
            <summary>Whether to force continuations to be executed asynchronously from producer writes.</summary>
        </member>
        <member name="F:System.Threading.Channels.UnboundedChannel`1._waitingReadersTail">
            <summary>Readers waiting for a notification that data is available.</summary>
        </member>
        <member name="F:System.Threading.Channels.UnboundedChannel`1._doneWriting">
            <summary>Set to non-null once Complete has been called.</summary>
        </member>
        <member name="M:System.Threading.Channels.UnboundedChannel`1.#ctor(System.Boolean)">
            <summary>Initialize the channel.</summary>
        </member>
        <member name="M:System.Threading.Channels.UnboundedChannel`1.UnboundedChannelReader.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.UnboundedChannel`1.UnboundedChannelWriter.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel. This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.UnboundedChannel`1.UnboundedChannelWriter.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="P:System.Threading.Channels.UnboundedChannel`1.SyncObj">
            <summary>Gets the object used to synchronize access to all state on this instance.</summary>
        </member>
        <member name="P:System.Threading.Channels.UnboundedChannel`1.ItemsCountForDebugger">
            <summary>Gets the number of items in the channel.  This should only be used by the debugger.</summary>
        </member>
        <member name="P:System.Threading.Channels.UnboundedChannel`1.ChannelIsClosedForDebugger">
            <summary>Report if the channel is closed or not. This should only be used by the debugger.</summary>
        </member>
        <member name="M:System.Threading.Channels.UnboundedChannel`1.System#Threading#Channels#IDebugEnumerable{T}#GetEnumerator">
            <summary>Gets an enumerator the debugger can use to show the contents of the channel.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.IProducerConsumerQueue`1">
            <summary>Represents a producer/consumer queue.</summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <remarks>This method is meant to be thread-safe subject to the particular nature of the implementation.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
            <remarks>This method is meant to be thread-safe subject to the particular nature of the implementation.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.IProducerConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
            <remarks>This method may or may not be thread-safe.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.IProducerConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>In many implementations, this method will not be thread-safe.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.IProducerConsumerQueue`1.GetCountSafe(System.Object)">
            <summary>A thread-safe way to get the number of items in the collection. May synchronize access by locking the provided synchronization object.</summary>
            <param name="syncObj">The sync object used to lock</param>
            <returns>The collection count</returns>
        </member>
        <member name="T:System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by any number of producers and consumers concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1.System#Collections#Concurrent#IProducerConsumerQueue{T}#Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1.System#Collections#Concurrent#IProducerConsumerQueue{T}#TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1.System#Collections#Concurrent#IProducerConsumerQueue{T}#IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1.System#Collections#Concurrent#IProducerConsumerQueue{T}#Count">
            <summary>Gets the number of items in the collection.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1.System#Collections#Concurrent#IProducerConsumerQueue{T}#GetCountSafe(System.Object)">
            <summary>A thread-safe way to get the number of items in the collection. May synchronize access by locking the provided synchronization object.</summary>
            <remarks>ConcurrentQueue.Count is thread safe, no need to acquire the lock.</remarks>
        </member>
        <member name="T:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1">
            <summary>
            Provides a producer/consumer queue safe to be used by only one producer and one consumer concurrently.
            </summary>
            <typeparam name="T">Specifies the type of data contained in the queue.</typeparam>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.InitialSegmentSize">
            <summary>The initial size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.MaxSegmentSize">
            <summary>The maximum size to use for segments (in number of elements).</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1._head">
            <summary>The head of the linked list of segments.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1._tail">
            <summary>The tail of the linked list of segments.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.#ctor">
            <summary>Initializes the queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Enqueue(`0)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.EnqueueSlow(`0,System.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0}.Segment@)">
            <summary>Enqueues an item into the queue.</summary>
            <param name="item">The item to enqueue.</param>
            <param name="segment">The segment in which to first attempt to store the item.</param>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryDequeue(`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryPeek(`0@)">
            <summary>Attempts to peek at an item in the queue.</summary>
            <param name="result">The peeked item.</param>
            <returns>true if an item could be peeked; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryDequeueSlow(System.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0}.Segment,`0[],System.Boolean,`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="segment">The segment from which the item was dequeued.</param>
            <param name="array">The array from <paramref name="segment"/>.</param>
            <param name="peek">true if this is only a peek operation; false if the item should be dequeued.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryDequeueIf(System.Predicate{`0},`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="predicate">The predicate that must return true for the item to be dequeued.  If null, all items implicitly return true.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.TryDequeueIfSlow(System.Predicate{`0},System.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0}.Segment,`0[],`0@)">
            <summary>Attempts to dequeue an item from the queue.</summary>
            <param name="predicate">The predicate that must return true for the item to be dequeued.  If null, all items implicitly return true.</param>
            <param name="array">The array from which the item was dequeued.</param>
            <param name="segment">The segment from which the item was dequeued.</param>
            <param name="result">The dequeued item.</param>
            <returns>true if an item could be dequeued; otherwise, false.</returns>
        </member>
        <member name="P:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.IsEmpty">
            <summary>Gets whether the collection is currently empty.</summary>
            <remarks>WARNING: This should not be used concurrently without further vetting.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>This method is not safe to use concurrently with any other members that may mutate the collection.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerable for the collection.</summary>
            <remarks>This method is not safe to use concurrently with any other members that may mutate the collection.</remarks>
        </member>
        <member name="P:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Count">
            <summary>Gets the number of items in the collection.</summary>
            <remarks>This method is not safe to use concurrently with any other members that may mutate the collection.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.System#Collections#Concurrent#IProducerConsumerQueue{T}#GetCountSafe(System.Object)">
            <summary>A thread-safe way to get the number of items in the collection. May synchronize access by locking the provided synchronization object.</summary>
            <remarks>The Count is not thread safe, so we need to acquire the lock.</remarks>
        </member>
        <member name="T:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment">
            <summary>A segment in the queue containing one or more items.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment._next">
            <summary>The next segment in the linked list of segments.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment._array">
            <summary>The data stored in this segment.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment._state">
            <summary>Details about the segment.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.Segment.#ctor(System.Int32)">
            <summary>Initializes the segment.</summary>
            <param name="size">The size to use for this segment.</param>
        </member>
        <member name="T:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState">
            <summary>Stores information about a segment.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._pad0">
            <summary>Padding to reduce false sharing between the segment's array and _first.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._first">
            <summary>The index of the current head in the segment.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._lastCopy">
            <summary>A copy of the current tail index.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._pad1">
            <summary>Padding to reduce false sharing between the first and last.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._firstCopy">
            <summary>A copy of the current head index.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._last">
            <summary>The index of the current tail in the segment.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SegmentState._pad2">
            <summary>Padding to reduce false sharing with the last and what's after the segment.</summary>
        </member>
        <member name="T:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView">
            <summary>Debugger type proxy for a SingleProducerSingleConsumerQueue of T.</summary>
        </member>
        <member name="F:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView._queue">
            <summary>The queue being visualized.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.#ctor(System.Collections.Concurrent.SingleProducerSingleConsumerQueue{`0})">
            <summary>Initializes the debug view.</summary>
            <param name="queue">The queue being debugged.</param>
        </member>
        <member name="P:System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1.SingleProducerSingleConsumerQueue_DebugView.Items">
            <summary>Gets the contents of the list.</summary>
        </member>
        <member name="T:System.Collections.Generic.Deque`1">
            <summary>Provides a double-ended queue data structure.</summary>
            <typeparam name="T">Type of the data stored in the dequeue.</typeparam>
        </member>
        <member name="P:System.SR.ChannelClosedException_DefaultMessage">
            <summary>The channel has been closed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_IncompleteAsyncOperation">
            <summary>The asynchronous operation has not completed.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_MultipleContinuations">
            <summary>Another continuation was already registered.</summary>
        </member>
        <member name="P:System.SR.InvalidOperation_IncorrectToken">
            <summary>The result of the operation was already consumed and may not be used again.</summary>
        </member>
        <member name="T:System.Runtime.InteropServices.LibraryImportAttribute">
            <summary>
            Attribute used to indicate a source generator should create a function for marshalling
            arguments instead of relying on the runtime to generate an equivalent marshalling function at run-time.
            </summary>
            <remarks>
            This attribute is meaningless if the source generator associated with it is not enabled.
            The current built-in source generator only supports C# and only supplies an implementation when
            applied to static, partial, non-generic methods.
            </remarks>
        </member>
        <member name="M:System.Runtime.InteropServices.LibraryImportAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.LibraryImportAttribute"/>.
            </summary>
            <param name="libraryName">Name of the library containing the import.</param>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.LibraryName">
            <summary>
            Gets the name of the library containing the import.
            </summary>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.EntryPoint">
            <summary>
            Gets or sets the name of the entry point to be called.
            </summary>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshalling">
            <summary>
            Gets or sets how to marshal string arguments to the method.
            </summary>
            <remarks>
            If this field is set to a value other than <see cref="F:System.Runtime.InteropServices.StringMarshalling.Custom" />,
            <see cref="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshallingCustomType" /> must not be specified.
            </remarks>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshallingCustomType">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> used to control how string arguments to the method are marshalled.
            </summary>
            <remarks>
            If this field is specified, <see cref="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshalling" /> must not be specified
            or must be set to <see cref="F:System.Runtime.InteropServices.StringMarshalling.Custom" />.
            </remarks>
        </member>
        <member name="P:System.Runtime.InteropServices.LibraryImportAttribute.SetLastError">
            <summary>
            Gets or sets whether the callee sets an error (SetLastError on Windows or errno
            on other platforms) before returning from the attributed method.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.StringMarshalling">
            <summary>
            Specifies how strings should be marshalled for generated p/invokes
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.StringMarshalling.Custom">
            <summary>
            Indicates the user is suppling a specific marshaller in <see cref="P:System.Runtime.InteropServices.LibraryImportAttribute.StringMarshallingCustomType"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.StringMarshalling.Utf8">
            <summary>
            Use the platform-provided UTF-8 marshaller.
            </summary>
        </member>
        <member name="F:System.Runtime.InteropServices.StringMarshalling.Utf16">
            <summary>
            Use the platform-provided UTF-16 marshaller.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:Internal.PaddingHelpers">
            <summary>A placeholder class for common padding constants and eventually routines.</summary>
        </member>
        <member name="F:Internal.PaddingHelpers.CACHE_LINE_SIZE">
            <summary>A size greater than or equal to the size of the most common CPU cache lines.</summary>
        </member>
        <member name="T:Internal.PaddingFor32">
            <summary>Padding structure used to minimize false sharing</summary>
        </member>
    </members>
</doc>
